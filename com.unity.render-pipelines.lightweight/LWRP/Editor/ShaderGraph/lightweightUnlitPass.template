Pass
{
    Name "StandardUnlit"
    Tags{"LightMode" = "LightweightForward"}

    // Material options generated by graph
${Tags}
${Blending}
${Culling}
${ZTest}
${ZWrite}
    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles
    #pragma exclude_renderers d3d11_9x
    #pragma target 2.0

    // -------------------------------------
    // Lightweight Pipeline keywords
    #pragma shader_feature _SAMPLE_GI

    // -------------------------------------
    // Unity defined keywords
    #pragma multi_compile_fog

    //--------------------------------------
    // GPU Instancing
    #pragma multi_compile_instancing
    
    #pragma vertex vert
    #pragma fragment frag

    // Defines generated by graph
${Defines}
    // Lighting include is needed because of GI
    #include "LWRP/ShaderLibrary/Core.hlsl"
    #include "LWRP/ShaderLibrary/Lighting.hlsl"
    #include "CoreRP/ShaderLibrary/Color.hlsl"
    #include "LWRP/ShaderLibrary/InputSurfaceUnlit.hlsl"
    #include "ShaderGraphLibrary/Functions.hlsl"

${Graph}
    struct GraphVertexOutput
    {
        float4 position : POSITION;

        // Interpolators defined by graph
${VertexOutputStruct}
        UNITY_VERTEX_INPUT_INSTANCE_ID
    };

    GraphVertexOutput vert (GraphVertexInput v)
    {
        // Vertex transformations performed by graph
${VertexShader}
        VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        // Vertex description inputs defined by graph
${VertexShaderDescriptionInputs}
        VertexDescription vd = PopulateVertexData(vdi);
        v.vertex.xyz = vd.Position;
        
        GraphVertexOutput o = (GraphVertexOutput)0;
        
        UNITY_SETUP_INSTANCE_ID(v);
        UNITY_TRANSFER_INSTANCE_ID(v, o);

        o.position = TransformObjectToHClip(v.vertex.xyz);
        // Vertex shader outputs defined by graph
${VertexShaderOutputs}
        return o;
    }

    half4 frag (GraphVertexOutput IN) : SV_Target
    {
        UNITY_SETUP_INSTANCE_ID(IN);

        // Pixel transformations performed by graph
${PixelShader}
        
        SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;
        // Surface description inputs defined by graph
${PixelShaderSurfaceInputs}

        SurfaceDescription surf = PopulateSurfaceData(surfaceInput);
        float3 Color = float3(0.5, 0.5, 0.5);
        float Alpha = 1;
        float AlphaClipThreshold = 0;
        // Surface description remap performed by graph
${PixelShaderSurfaceRemap}
        
 #if _AlphaClip
        clip(Alpha - AlphaClipThreshold);
#endif
        return half4(Color, Alpha);
    }
    ENDHLSL
}